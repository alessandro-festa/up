{"version":3,"file":"universal-proxy-0.1.0.umd.min.83.js","mappings":"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","sources":["webpack://universal-proxy-0.1.0/./services/mcp-service.ts","webpack://universal-proxy-0.1.0/./config/api-config.ts"],"sourcesContent":["// MCP Service\n\nimport axios from 'axios';\nimport { API_BASE_URLS, MCP_ENDPOINTS, getApiConfig } from '../config/api-config';\nimport type {\n  Adapter,\n  AdapterConfig,\n  AdapterHealth,\n  Session,\n  SessionMetrics,\n  AdapterToken,\n  TokenValidationResult,\n  ClientTokenRequest,\n\n  DiscoveryScan,\n  DiscoveryScanConfig,\n  RegisterServerRequest,\n  RegistryServer as EnhancedRegistryServer,\n  RegistryBrowseOptions,\n  RegistryBrowseResult,\n  DeploymentConfig,\n  DeploymentRequest,\n  DeploymentResult,\n  AdapterMetrics,\n  SystemMetrics,\n  PluginService as EnhancedPluginService,\n  UploadRequest\n} from '../types/mcp-types';\n\nexport const apiClient = axios.create({\n  baseURL: API_BASE_URLS.MCP_GATEWAY,\n  timeout: getApiConfig().timeout,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\n// Function to update the base URL\nexport const updateApiBaseUrl = (newBaseUrl: string) => {\n  const cleanUrl = newBaseUrl.replace(/\\/$/, ''); // Remove trailing slash\n  apiClient.defaults.baseURL = `${cleanUrl}/api/v1`;\n};\n\nexport interface AdapterData {\n  name: string;\n  imageName: string;\n  imageVersion: string;\n  description: string;\n  connectionType: string;\n  protocol: string;\n  replicaCount: number;\n  useWorkloadIdentity: boolean;\n  environmentVariables?: Record<string, string>;\n  command?: string;\n  args?: string[];\n   originalServer?: DiscoveredServer;\n   remoteUrl?: string;\n   authentication?: {\n     required: boolean;\n     type: string;\n   };\n}\n\nexport interface ScanConfig {\n  maxConcurrent?: number;\n  timeout?: string;\n  scanRanges?: string[];\n  ports?: string[];\n  excludeAddresses?: string[];\n  excludeProxy?: boolean;\n}\n\nexport interface ScanResult {\n  id: string;\n  status: 'running' | 'completed' | 'failed' | 'pending';\n  startTime?: string;\n  endTime?: string;\n  config?: ScanConfig;\n  progress?: number;\n  message?: string;\n  results?: DiscoveredServer[];\n  error?: string;\n  // Legacy fields for backward compatibility\n  scanId?: string;\n  scan_id?: string;\n  discovered_servers?: DiscoveredServer[];\n}\n\nexport interface AdapterResource {\n  name: string;\n  status: string;\n  description?: string;\n  protocol: string;\n  connectionType: string;\n  command?: string;\n  args?: string[];\n  environmentVariables?: Record<string, string>;\n  replicaCount: number;\n  useWorkloadIdentity: boolean;\n  createdAt: string;\n  lastActivity?: string;\n  phase?: string;\n  message?: string;\n  lastCheck?: string;\n  imageName?: string;\n  imageVersion?: string;\n   originalServer?: DiscoveredServer;\n   remoteUrl?: string;\n   authentication?: {\n     required: boolean;\n     type: string;\n     token?: string;\n   };\n   createdBy?: string;\n  lastUpdatedAt?: string;\n  // Legacy fields for backward compatibility\n  id?: string;\n  endpoint?: string;\n  errorCount?: number;\n  requestCount?: number;\n  lastActive?: string;\n}\n\nexport interface DiscoveredServer {\n  id: string;\n  address: string;\n  protocol: string;\n  connection: string;\n  status: string;\n  lastSeen: string;\n  port?: number;\n  discoveredAt?: string;\n  vulnerability_score?: 'high' | 'medium' | 'low';\n  scan_results?: any;\n  name?: string;\n  metadata?: {\n    auth_type?: string;\n    detectionMethod?: string;\n  };\n  security_findings?: any[];\n}\n\nexport interface RegistryServer {\n  _meta?: Record<string, any>;\n  id: string;\n  name: string;\n  description: string;\n  version: string;\n  protocol: string;\n  url: string;\n  validation_status: string;\n  discovered_at: string;\n  iconurl?: string;\n  repository?: {\n    source: string;\n    url: string;\n  };\n  packages: RegistryPackage[];\n  tools: RegistryTool[];\n}\n\nexport interface RegistryPackage {\n  identifier: string;\n  registryType: string;\n  transport: {\n    type: string;\n  };\n  environmentVariables?: RegistryEnvironmentVariable[];\n}\n\nexport interface RegistryEnvironmentVariable {\n  name: string;\n  description: string;\n  default: string;\n  format: string;\n  isSecret: boolean;\n}\n\nexport interface RegistryTool {\n  name: string;\n  description: string;\n  input_schema: Record<string, any>;\n}\n\n// Session Management Interfaces\nexport interface SessionInfo {\n  sessionId: string;\n  adapterName: string;\n  targetAddress: string;\n  connectionType: string;\n  createdAt: string;\n  lastActivity: string;\n  status: 'active' | 'inactive' | 'error';\n  metadata?: {\n    protocolVersion?: string;\n    clientInfo?: {\n      name: string;\n      version: string;\n    };\n  };\n}\n\nexport interface SessionListResponse {\n  adapterName: string;\n  sessions: SessionInfo[];\n}\n\nexport interface CreateSessionRequest {\n  forceReinitialize?: boolean;\n  clientInfo?: {\n    name: string;\n    version: string;\n  };\n}\n\nexport interface CreateSessionResponse {\n  sessionId: string;\n  message: string;\n  adapterName: string;\n}\n\n// Plugin Service Management Interfaces\nexport interface PluginService {\n  service_id: string;\n  service_type: string;\n  service_url: string;\n  version: string;\n  status: 'healthy' | 'unhealthy' | 'unknown';\n  capabilities: PluginCapability[];\n  registered_at: string;\n  last_health_check: string;\n}\n\nexport interface PluginCapability {\n  path: string;\n  methods: string[];\n  description: string;\n}\n\nexport interface PluginServiceListResponse {\n  services: PluginService[];\n}\n\nexport interface RegisterServiceRequest {\n  service_id: string;\n  service_type: string;\n  service_url: string;\n  version: string;\n  capabilities: PluginCapability[];\n}\n\nexport interface ServiceHealthResponse {\n  service_id: string;\n  status: 'healthy' | 'unhealthy' | 'unknown';\n  message: string;\n  timestamp: string;\n  version: string;\n  uptime?: string;\n}\n\n// MCP Communication Interfaces\nexport interface MCPMessage {\n  jsonrpc: string;\n  id?: number | string;\n  method?: string;\n  params?: Record<string, any>;\n  result?: any;\n  error?: any;\n}\n\nexport interface MCPSessionRequest {\n  sessionId: string;\n  message: MCPMessage;\n}\n\nexport class MCPService {\n  static async createAdapter(data: AdapterData) {\n    try {\n      const response = await apiClient.post(MCP_ENDPOINTS.ADAPTERS, data);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to create adapter:', error);\n      throw error;\n    }\n  }\n\n  static async registerDiscoveredServer(serverId: string) {\n    try {\n      const response = await apiClient.post(MCP_ENDPOINTS.REGISTER_SERVER, { DiscoveredServerID: serverId });\n      // API returns 201 Created with no content, so return success status\n      return { success: response.status === 201, status: response.status };\n    } catch (error) {\n      console.error('Failed to register discovered server:', error);\n      throw error;\n    }\n  }\n\n  static async startScan(config: ScanConfig): Promise<ScanResult> {\n    try {\n      const response = await apiClient.post(MCP_ENDPOINTS.DISCOVERY_SCAN, config);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to start scan:', error);\n      throw error;\n    }\n  }\n\n  static async getScanStatus(scanId: string): Promise<ScanResult> {\n    try {\n      const response = await apiClient.get(`${MCP_ENDPOINTS.DISCOVERY_SCAN}/${scanId}`);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get scan status:', error);\n      throw error;\n    }\n  }\n\n  static async getScanResults(scanId: string): Promise<ScanResult> {\n    try {\n      const response = await apiClient.get(`${MCP_ENDPOINTS.DISCOVERY_SCAN}/${scanId}`);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get scan results:', error);\n      throw error;\n    }\n  }\n\n  static async getAdapters(): Promise<AdapterResource[]> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.ADAPTERS);\n      return response.data || [];\n    } catch (error) {\n      console.error('Failed to fetch adapters:', error);\n      return [];\n    }\n  }\n\n  static async getAdapter(name: string): Promise<AdapterResource | null> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.ADAPTER_DETAILS(name));\n      return response.data;\n    } catch (error) {\n      console.error('Failed to fetch adapter:', error);\n      return null;\n    }\n  }\n\n  static async deleteAdapter(name: string) {\n    try {\n      await apiClient.delete(MCP_ENDPOINTS.ADAPTER_DELETE(name));\n    } catch (error) {\n      console.error('Failed to delete adapter:', error);\n      throw error;\n    }\n  }\n\n  static async getMetrics() {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.METRICS);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get metrics:', error);\n      throw error;\n    }\n  }\n\n  static async getRegistryServers(): Promise<RegistryServer[]> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.REGISTRY_BROWSE);\n      return response.data.servers || [];\n    } catch (error) {\n      console.error('Failed to fetch registry servers:', error);\n      return [];\n    }\n  }\n\n  static async getPublicRegistryServers(): Promise<RegistryServer[]> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.REGISTRY_PUBLIC);\n      return response.data || [];\n    } catch (error) {\n      console.error('Failed to fetch public registry servers:', error);\n      return [];\n    }\n  }\n\n  static async getPublicRegistryServersBySource(source: string): Promise<RegistryServer[]> {\n    try {\n      const response = await apiClient.get(`${MCP_ENDPOINTS.REGISTRY_PUBLIC}?source=${source}`);\n      return response.data || [];\n    } catch (error) {\n      console.error(`Failed to fetch registry servers for source ${source}:`, error);\n      return [];\n    }\n  }\n\n  static async getRegistryServer(id: string): Promise<RegistryServer | null> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.REGISTRY_DETAILS(id));\n      return response.data;\n    } catch (error) {\n      console.error(`Failed to get registry server ${id}:`, error);\n      return null;\n    }\n  }\n\n  static async browseRegistryServers(): Promise<RegistryServer[]> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.REGISTRY_BROWSE);\n      return response.data || [];\n    } catch (error) {\n      console.error('Failed to browse registry servers:', error);\n      return [];\n    }\n  }\n\n  // Adapter Details and Status\n  static async getAdapterDetails(name: string): Promise<AdapterResource | null> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.ADAPTER_DETAILS(name));\n      return response.data;\n    } catch (error) {\n      console.error('Failed to fetch adapter details:', error);\n      return null;\n    }\n  }\n\n  static async getAdapterStatus(name: string): Promise<AdapterResource | null> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.ADAPTER_STATUS(name));\n      return response.data;\n    } catch (error) {\n      console.error('Failed to fetch adapter status:', error);\n      return null;\n    }\n  }\n\n  static async updateAdapter(name: string, updates: Partial<AdapterData>): Promise<AdapterResource> {\n    try {\n      const response = await apiClient.put(MCP_ENDPOINTS.ADAPTER_UPDATE(name), updates);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to update adapter:', error);\n      throw error;\n    }\n  }\n\n  // Session Management\n  static async listSessions(adapterName: string): Promise<SessionListResponse> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.SESSIONS(adapterName));\n      return response.data;\n    } catch (error) {\n      console.error('Failed to list sessions:', error);\n      throw error;\n    }\n  }\n\n  static async getSessionDetails(adapterName: string, sessionId: string): Promise<SessionInfo> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.SESSION_DETAILS(adapterName, sessionId));\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get session details:', error);\n      throw error;\n    }\n  }\n\n  static async createSession(adapterName: string, request: CreateSessionRequest): Promise<CreateSessionResponse> {\n    try {\n      const response = await apiClient.post(MCP_ENDPOINTS.SESSION_CREATE(adapterName), request);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to create session:', error);\n      throw error;\n    }\n  }\n\n  static async deleteSession(adapterName: string, sessionId: string) {\n    try {\n      await apiClient.delete(MCP_ENDPOINTS.SESSION_DELETE(adapterName, sessionId));\n    } catch (error) {\n      console.error('Failed to delete session:', error);\n      throw error;\n    }\n  }\n\n  static async deleteAllSessions(adapterName: string) {\n    try {\n      await apiClient.delete(MCP_ENDPOINTS.SESSION_DELETE_ALL(adapterName));\n    } catch (error) {\n      console.error('Failed to delete all sessions:', error);\n      throw error;\n    }\n  }\n\n  // Plugin Service Management\n  static async listPluginServices(): Promise<PluginServiceListResponse> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.PLUGIN_SERVICES);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to list plugin services:', error);\n      throw error;\n    }\n  }\n\n  static async registerPluginService(request: RegisterServiceRequest) {\n    try {\n      const response = await apiClient.post(MCP_ENDPOINTS.PLUGIN_REGISTER, request);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to register plugin service:', error);\n      throw error;\n    }\n  }\n\n  static async getServiceHealth(serviceId: string): Promise<ServiceHealthResponse> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.PLUGIN_HEALTH(serviceId));\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get service health:', error);\n      throw error;\n    }\n  }\n\n  static async unregisterPluginService(serviceId: string) {\n    try {\n      await apiClient.delete(MCP_ENDPOINTS.PLUGIN_UNREGISTER(serviceId));\n    } catch (error) {\n      console.error('Failed to unregister plugin service:', error);\n      throw error;\n    }\n  }\n\n  // MCP Communication\n  static async sendMCPMessage(adapterName: string, sessionId: string, message: MCPMessage): Promise<MCPMessage> {\n    try {\n      const response = await apiClient.post(MCP_ENDPOINTS.ADAPTER_MESSAGES(adapterName), message, {\n        headers: {\n          'mcp-session-id': sessionId,\n          'Content-Type': 'application/json'\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Failed to send MCP message:', error);\n      throw error;\n    }\n  }\n\n  static async establishMCPConnection(adapterName: string, message: MCPMessage): Promise<any> {\n    try {\n      const response = await apiClient.post(MCP_ENDPOINTS.ADAPTER_MCP(adapterName), message, {\n        headers: {\n          'Accept': 'application/json, text/event-stream'\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Failed to establish MCP connection:', error);\n      throw error;\n    }\n  }\n\n  // Enhanced Discovery Methods\n  static async startDiscoveryScan(config: any): Promise<any> {\n    try {\n      const response = await apiClient.post(MCP_ENDPOINTS.DISCOVERY_SCAN, config);\n      return response.data;\n    } catch (error: any) {\n      console.error('Failed to start discovery scan:', error);\n      // Check if it's a CORS error\n      if (error.code === 'ERR_NETWORK' || error.message?.includes('CORS')) {\n        throw new Error('CORS error: Unable to connect to MCP Gateway. Please ensure the MCP Gateway server is running and configured to allow cross-origin requests from this domain.');\n      }\n      throw error;\n    }\n  }\n\n  static async getDiscoveryServers(): Promise<DiscoveredServer[]> {\n    try {\n      console.log('Calling getDiscoveryServers with URL:', apiClient.defaults.baseURL + MCP_ENDPOINTS.DISCOVERY_SERVERS);\n      const response = await apiClient.get(MCP_ENDPOINTS.DISCOVERY_SERVERS);\n      console.log('getDiscoveryServers response:', response);\n      const data = response.data;\n      console.log('getDiscoveryServers data:', data);\n\n      // API returns {count: number, servers: DiscoveredServer[]}\n      if (data && typeof data === 'object' && Array.isArray(data.servers)) {\n        return data.servers;\n      } else if (Array.isArray(data)) {\n        // Fallback for legacy format\n        return data;\n      } else {\n        console.warn('getDiscoveryServers returned unexpected format:', data);\n        return [];\n      }\n    } catch (error) {\n      console.error('Failed to get discovery servers:', error);\n      return [];\n    }\n  }\n\n  static async getDiscoveryServerDetails(id: string): Promise<DiscoveredServer | null> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.DISCOVERY_SERVER_DETAILS(id));\n      return response.data;\n    } catch (error) {\n      console.error(`Failed to get discovery server ${id}:`, error);\n      return null;\n    }\n  }\n\n  static async registerDiscoveredServerEnhanced(request: RegisterServerRequest): Promise<AdapterResource> {\n    try {\n      const response = await apiClient.post(MCP_ENDPOINTS.DISCOVERY_REGISTER, request);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to register discovered server:', error);\n      throw error;\n    }\n  }\n\n  // Enhanced Registry Methods\n  static async syncOfficialRegistry(): Promise<{ synced: number; updated: number }> {\n    try {\n      const response = await apiClient.post(MCP_ENDPOINTS.REGISTRY_SYNC_OFFICIAL);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to sync official registry:', error);\n      throw error;\n    }\n  }\n\n  static async uploadToRegistry(request: UploadRequest): Promise<EnhancedRegistryServer> {\n    try {\n      const response = await apiClient.post(MCP_ENDPOINTS.REGISTRY_UPLOAD, request);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to upload to registry:', error);\n      throw error;\n    }\n  }\n\n  static async bulkUploadToRegistry(requests: UploadRequest[]): Promise<EnhancedRegistryServer[]> {\n    try {\n      const response = await apiClient.post(MCP_ENDPOINTS.REGISTRY_UPLOAD_BULK, { servers: requests });\n      return response.data;\n    } catch (error) {\n      console.error('Failed to bulk upload to registry:', error);\n      throw error;\n    }\n  }\n\n  static async uploadLocalMcp(name: string, path: string, options: {\n    description?: string\n    category?: string\n    tags?: string[]\n    metadata?: Record<string, any>\n  } = {}): Promise<EnhancedRegistryServer> {\n    try {\n      const response = await apiClient.post(MCP_ENDPOINTS.REGISTRY_UPLOAD_LOCAL_MCP, {\n        name,\n        path,\n        ...options\n      });\n      return response.data;\n    } catch (error) {\n      console.error(`Failed to upload local MCP ${name}:`, error);\n      throw error;\n    }\n  }\n\n  static async getRegistryServerDetailsEnhanced(id: string): Promise<EnhancedRegistryServer | null> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.REGISTRY_DETAILS(id));\n      return response.data;\n    } catch (error) {\n      console.error(`Failed to get registry server ${id}:`, error);\n      return null;\n    }\n  }\n\n  // Deployment Management\n  static async getDeploymentConfig(serverId: string): Promise<DeploymentConfig> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.DEPLOYMENT_CONFIG(serverId));\n      return response.data;\n    } catch (error) {\n      console.error(`Failed to get deployment config for ${serverId}:`, error);\n      throw error;\n    }\n  }\n\n  static async deployServer(request: DeploymentRequest): Promise<DeploymentResult> {\n    try {\n      const response = await apiClient.post(MCP_ENDPOINTS.DEPLOYMENT_DEPLOY, request);\n      return response.data;\n    } catch (error) {\n      console.error(`Failed to deploy server ${request.serverId}:`, error);\n      throw error;\n    }\n  }\n\n  // Metrics and Monitoring\n  static async getAdapterMetrics(adapterName: string): Promise<AdapterMetrics> {\n    try {\n      const response = await apiClient.get(`${MCP_ENDPOINTS.ADAPTER_DETAILS(adapterName)}/metrics`);\n      return response.data;\n    } catch (error) {\n      console.error(`Failed to get metrics for adapter ${adapterName}:`, error);\n      throw error;\n    }\n  }\n\n  static async getSystemMetrics(): Promise<SystemMetrics> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.METRICS);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get system metrics:', error);\n      throw error;\n    }\n  }\n\n  // Plugin Services by Type\n  static async getPluginServicesByType(serviceType: string): Promise<PluginServiceListResponse> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.PLUGIN_SERVICES_BY_TYPE(serviceType));\n      return response.data;\n    } catch (error) {\n      console.error(`Failed to get plugin services by type ${serviceType}:`, error);\n      throw error;\n    }\n  }\n\n  // System Health\n  static async ping(): Promise<boolean> {\n    try {\n      // Health endpoint is at root level, not under /api/v1\n      const baseUrl = apiClient.defaults.baseURL?.replace('/api/v1', '') || 'http://localhost:8911';\n      const response = await axios.get(`${baseUrl}/health`);\n      // Check if the service responds with healthy status\n      return response.data?.status === 'healthy';\n    } catch (error) {\n      console.error('Failed to ping MCP Gateway:', error);\n      return false;\n    }\n  }\n\n  static async getApiDocs(): Promise<any> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.DOCS);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get API docs:', error);\n      throw error;\n    }\n  }\n\n  static async getSwaggerSpec(): Promise<any> {\n    try {\n      const response = await apiClient.get(MCP_ENDPOINTS.SWAGGER_JSON);\n      return response.data;\n    } catch (error) {\n      console.error('Failed to get Swagger spec:', error);\n      throw error;\n    }\n  }\n}","/**\n * API Configuration for SUSE AI Rancher Extension\n * Centralizes all API endpoints and base URLs\n */\n\n// Base URLs for different services\nexport const getApiBaseUrls = (serviceUrl?: string) => ({\n  MCP_GATEWAY: serviceUrl ? `${serviceUrl}/api/v1` : 'http://localhost:8911/api/v1',\n  SMART_AGENTS: 'http://localhost:8910',\n  RANCHER: window.location.origin\n});\n\nexport const API_BASE_URLS = getApiBaseUrls();\n\n// API Endpoints for MCP Gateway\nexport const MCP_ENDPOINTS = {\n  // Adapter Management\n  ADAPTERS: '/adapters',\n  ADAPTER_DETAILS: (name: string) => `/adapters/${name}`,\n  ADAPTER_STATUS: (name: string) => `/adapters/${name}/status`,\n  ADAPTER_LOGS: (name: string) => `/adapters/${name}/logs`,\n  ADAPTER_UPDATE: (name: string) => `/adapters/${name}`,\n  ADAPTER_DELETE: (name: string) => `/adapters/${name}`,\n  \n  // Session Management\n  SESSIONS: (name: string) => `/adapters/${name}/sessions`,\n  SESSION_DETAILS: (name: string, sessionId: string) => `/adapters/${name}/sessions/${sessionId}`,\n  SESSION_CREATE: (name: string) => `/adapters/${name}/sessions`,\n  SESSION_DELETE: (name: string, sessionId: string) => `/adapters/${name}/sessions/${sessionId}`,\n  SESSION_DELETE_ALL: (name: string) => `/adapters/${name}/sessions`,\n  \n  // Token Management\n  ADAPTER_TOKEN: (name: string) => `/adapters/${name}/token`,\n  ADAPTER_TOKEN_REFRESH: (name: string) => `/adapters/${name}/token/refresh`,\n  ADAPTER_TOKEN_VALIDATE: (name: string) => `/adapters/${name}/token/validate`,\n  ADAPTER_CLIENT_TOKEN: (name: string) => `/adapters/${name}/client-token`,\n  ADAPTER_TEST_AUTH: (name: string) => `/adapters/${name}/test-auth`,\n  ADAPTER_VALIDATE_AUTH: (name: string) => `/adapters/${name}/validate-auth`,\n  \n  // MCP Communication\n  ADAPTER_SSE: (name: string) => `/adapters/${name}/sse`,\n  ADAPTER_MESSAGES: (name: string) => `/adapters/${name}/messages`,\n  ADAPTER_MCP: (name: string) => `/adapters/${name}/mcp`,\n  ADAPTER_WEBSOCKET: (name: string) => `/adapters/${name}/ws`,\n  \n  // Network Discovery\n  DISCOVERY_SCAN: '/discovery/scan',\n  DISCOVERY_SERVERS: '/discovery/servers',\n  DISCOVERY_SERVER_DETAILS: (id: string) => `/discovery/servers/${id}`,\n  DISCOVERY_REGISTER: '/discovery/register',\n  \n  // Legacy endpoints (for backward compatibility)\n  SCAN_START: '/scan',\n  SCAN_STATUS: (scanId: string) => `/scan/${scanId}`,\n  SERVERS: '/servers',\n  REGISTER_SERVER: '/discovery/register',\n  \n  // Registry Management\n  REGISTRY_BROWSE: '/registry/browse',\n  REGISTRY_PUBLIC: '/registry/public',\n  REGISTRY_SYNC_OFFICIAL: '/registry/sync/official',\n  REGISTRY_UPLOAD: '/registry/upload',\n  REGISTRY_UPLOAD_BULK: '/registry/upload/bulk',\n  REGISTRY_UPLOAD_LOCAL_MCP: '/registry/upload/local-mcp',\n  REGISTRY_DETAILS: (id: string) => `/registry/${id}`,\n  \n  // Deployment Management\n  DEPLOYMENT_CONFIG: (serverId: string) => `/deployment/config/${serverId}`,\n  DEPLOYMENT_DEPLOY: '/deployment/deploy',\n  \n  // Plugin Services\n  PLUGIN_SERVICES: '/plugins/services',\n  PLUGIN_REGISTER: '/plugins/register',\n  PLUGIN_HEALTH: (serviceId: string) => `/plugins/services/${serviceId}/health`,\n  PLUGIN_UNREGISTER: (serviceId: string) => `/plugins/services/${serviceId}`,\n  PLUGIN_SERVICES_BY_TYPE: (serviceType: string) => `/plugins/services/type/${serviceType}`,\n  \n   // System\n   HEALTH: '/health',\n  METRICS: '/metrics',\n  DOCS: '/docs',\n  SWAGGER_JSON: '/swagger/doc.json'\n} as const;\n\n// API Endpoints for Smart Agents\nexport const SMART_AGENTS_ENDPOINTS = {\n  AGENTS: '/agents',\n  AGENT_DETAILS: (id: string) => `/agents/${id}`,\n  AGENT_CREATE: '/agents',\n  AGENT_UPDATE: (id: string) => `/agents/${id}`,\n  AGENT_DELETE: (id: string) => `/agents/${id}`\n} as const;\n\n// API Configuration\nexport const API_CONFIG = {\n  // Default timeout for requests (in milliseconds)\n  DEFAULT_TIMEOUT: 10000,\n  \n  // Retry configuration\n  RETRY_ATTEMPTS: 3,\n  RETRY_DELAY: 1000,\n  \n  // Rate limiting\n  RATE_LIMITS: {\n    MANAGEMENT: 100, // requests per minute\n    COMMUNICATION: 1000, // requests per minute\n    HEALTH_CHECK: Infinity // unlimited\n  },\n  \n  // Headers\n  DEFAULT_HEADERS: {\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  },\n  \n  // SSE Headers\n  SSE_HEADERS: {\n    'Accept': 'text/event-stream',\n    'Cache-Control': 'no-cache'\n  },\n  \n  // WebSocket configuration\n  WS_CONFIG: {\n    protocols: ['mcp-v1'],\n    reconnectAttempts: 5,\n    reconnectDelay: 2000\n  }\n} as const;\n\n// Environment-specific configuration\nexport const getApiConfig = () => {\n  const isDevelopment = process.env.NODE_ENV === 'development';\n  \n  return {\n    baseURL: API_BASE_URLS.MCP_GATEWAY,\n    timeout: API_CONFIG.DEFAULT_TIMEOUT,\n    headers: API_CONFIG.DEFAULT_HEADERS,\n    retryAttempts: isDevelopment ? 1 : API_CONFIG.RETRY_ATTEMPTS,\n    enableLogging: isDevelopment,\n    validateStatus: (status: number) => status >= 200 && status < 300\n  };\n};\n\n// Helper function to build full URLs\nexport const buildUrl = (base: string, endpoint: string): string => {\n  return `${base.replace(/\\/$/, '')}${endpoint}`;\n};\n\n// Helper function to get MCP Gateway URLs\nexport const getMcpUrl = (endpoint: string): string => {\n  return buildUrl(API_BASE_URLS.MCP_GATEWAY, endpoint);\n};\n\n// Helper function to get Smart Agents URLs\nexport const getSmartAgentsUrl = (endpoint: string): string => {\n  return buildUrl(API_BASE_URLS.SMART_AGENTS, endpoint);\n};\n\nexport default {\n  API_BASE_URLS,\n  MCP_ENDPOINTS,\n  SMART_AGENTS_ENDPOINTS,\n  API_CONFIG,\n  getApiConfig,\n  buildUrl,\n  getMcpUrl,\n  getSmartAgentsUrl\n};"],"names":["apiClient","axios","create","baseURL","API_BASE_URLS","MCP_GATEWAY","timeout","getApiConfig","headers","MCPService","createAdapter","data","response","post","MCP_ENDPOINTS","ADAPTERS","error","console","registerDiscoveredServer","serverId","REGISTER_SERVER","DiscoveredServerID","success","status","startScan","config","DISCOVERY_SCAN","getScanStatus","scanId","get","getScanResults","getAdapters","getAdapter","name","ADAPTER_DETAILS","deleteAdapter","delete","ADAPTER_DELETE","getMetrics","METRICS","getRegistryServers","REGISTRY_BROWSE","servers","getPublicRegistryServers","REGISTRY_PUBLIC","getPublicRegistryServersBySource","source","getRegistryServer","id","REGISTRY_DETAILS","browseRegistryServers","getAdapterDetails","getAdapterStatus","ADAPTER_STATUS","updateAdapter","updates","put","ADAPTER_UPDATE","listSessions","adapterName","SESSIONS","getSessionDetails","sessionId","SESSION_DETAILS","createSession","request","SESSION_CREATE","deleteSession","SESSION_DELETE","deleteAllSessions","SESSION_DELETE_ALL","listPluginServices","PLUGIN_SERVICES","registerPluginService","PLUGIN_REGISTER","getServiceHealth","serviceId","PLUGIN_HEALTH","unregisterPluginService","PLUGIN_UNREGISTER","sendMCPMessage","message","ADAPTER_MESSAGES","establishMCPConnection","ADAPTER_MCP","startDiscoveryScan","code","includes","Error","getDiscoveryServers","log","defaults","DISCOVERY_SERVERS","Array","isArray","warn","getDiscoveryServerDetails","DISCOVERY_SERVER_DETAILS","registerDiscoveredServerEnhanced","DISCOVERY_REGISTER","syncOfficialRegistry","REGISTRY_SYNC_OFFICIAL","uploadToRegistry","REGISTRY_UPLOAD","bulkUploadToRegistry","requests","REGISTRY_UPLOAD_BULK","uploadLocalMcp","path","options","REGISTRY_UPLOAD_LOCAL_MCP","getRegistryServerDetailsEnhanced","getDeploymentConfig","DEPLOYMENT_CONFIG","deployServer","DEPLOYMENT_DEPLOY","getAdapterMetrics","getSystemMetrics","getPluginServicesByType","serviceType","PLUGIN_SERVICES_BY_TYPE","ping","baseUrl","replace","getApiDocs","DOCS","getSwaggerSpec","SWAGGER_JSON","getApiBaseUrls","serviceUrl","SMART_AGENTS","RANCHER","window","location","origin","ADAPTER_LOGS","ADAPTER_TOKEN","ADAPTER_TOKEN_REFRESH","ADAPTER_TOKEN_VALIDATE","ADAPTER_CLIENT_TOKEN","ADAPTER_TEST_AUTH","ADAPTER_VALIDATE_AUTH","ADAPTER_SSE","ADAPTER_WEBSOCKET","SCAN_START","SCAN_STATUS","SERVERS","HEALTH","SMART_AGENTS_ENDPOINTS","AGENTS","AGENT_DETAILS","AGENT_CREATE","AGENT_UPDATE","AGENT_DELETE","API_CONFIG","DEFAULT_TIMEOUT","RETRY_ATTEMPTS","RETRY_DELAY","RATE_LIMITS","MANAGEMENT","COMMUNICATION","HEALTH_CHECK","Infinity","DEFAULT_HEADERS","SSE_HEADERS","WS_CONFIG","protocols","reconnectAttempts","reconnectDelay","isDevelopment","process","retryAttempts","enableLogging","validateStatus","buildUrl","base","endpoint","getMcpUrl"],"sourceRoot":""}